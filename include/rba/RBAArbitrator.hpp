// Copyright (c) 2018 DENSO CORPORATION. All rights reserved.
/**
 * @cond japanese
 * 調停FWクラス
 * @endcond
 *
 * @cond english
 * Arbitrator Logic class
 * @endcond
 */

#ifndef RBAARBITORATOR_HPP
#define RBAARBITORATOR_HPP

#ifdef _MSC_VER
#ifdef _WINDLL
#define DLL_EXPORT __declspec(dllexport)
#else
#define DLL_EXPORT __declspec(dllimport)
#endif
#else
#define DLL_EXPORT
#endif

#include <string>
#include <list>
#include <memory>
#include <mutex>
#include <deque>
#include "RBAModel.hpp"
#include "RBAResult.hpp"
#include "RBARequestQueMember.hpp"
#include "RBAResultSet.hpp"
#include "RBAResultImpl.hpp"

/**
 * @cond japanese
 * @namespace rba
 * @brief ルールベース調停(RBA : Rule Based Arbitration)FWが定義する名前空間
 * @endcond
 *
 * @cond english
 * @namespace rba
 * @brief The namespace defined by Rule Based Arbitration Framework.
 * @endcond
 */
namespace rba
{

// internal {
#ifdef RBA_USE_LOG
class RBALogManager;
#endif

class RBARuleObject;
class RBAExpression;
class RBAModelImpl;
class RBAAffectInfo;
class RBARollbacker;
class RBAWindowRouter;
class RBAConstraintImpl;
// }

/**
 * @cond japanese
 * @class RBAArbitrator
 * モデルから生成されたルール(制約)に基づいて調停処理を実行するオブジェクト。
 * コンストラクタでrba::RBAJsonParserを使って生成したモデルをセットして使用する。
 * @endcond
 * @cond english
 * @class RBAArbitrator
 * An object that performs arbitration processing based on rules
 * generated from a model.<br>
 * Set the model generated using rba::RBAJsonParser in the constructor.
 * @endcond
 */
class DLL_EXPORT RBAArbitrator
{
public:
  /**
   * @cond japanese
   * @brief 調停FW本体のコンストラクタ
   * @param newModel 調停処理で使用するモデル。
   * モデルはrba::RBAJsonParserを使って生成できる。
   * @endcond
   *
   * @cond english
   * @brief Arbitrator logic constractor.
   * @param newModel Processing model.
   * The model is generated by rba::RBAJsonParser.
   * @endcond
   */
  RBAArbitrator()=default;
  RBAArbitrator(RBAModel* newModel);

  /**
   * @cond japanese
   * @brief 調停FW本体のデストラクタ
   * @endcond
   *
   * @cond english
   * @brief Arbitrator logic destractor.
   * @endcond
   */
  RBAArbitrator(const RBAArbitrator&)=delete;
  RBAArbitrator(const RBAArbitrator&&)=delete;
  RBAArbitrator& operator=(const RBAArbitrator&)=delete;
  RBAArbitrator& operator=(const RBAArbitrator&&)=delete;
  virtual ~RBAArbitrator() noexcept;

public:

  /**
   * @cond japanese
   * @brief 調停処理で使用するモデルをセットする
   * @param newModel 調停処理で使用するモデル
   * @details 調停FW本体のコンストラクタでセットしたモデルやこの関数でセットしたモデルを新しいモデルに置き換える。
   * 1つの調停FWオブジェクトには、常に1つのモデルがセットされる。
   * モデルは rba::RBAJsonParserを使って生成できる。
   * nullptrなど不正なモデルのセットを要求された場合は何もしない。
   * @endcond
   * @cond english
   * @brief Sets the model for arbitration
   * The model is generated by rba::RBAJsonParser.
   * @param newModel The model for arbitration
   * @details Replace the model with newModel. An arbitrator has only one model at all times.
   * Model can be generated by using rba::RBAJsonParser.
   * nullptr can not be set.
   * @endcond
   */
  void setModel(RBAModel* newModel);

  /**
   * @cond japanese
   * @brief 調停FW本体にセットされているモデルを取得する
   * @return 調停FW本体にセットされているモデル
   * @details 調停FWには必ずモデルがセットされているので、nullptrを返すことはない。
   * @endcond
   * @cond english
   * @brief Returns the model for arbitration
   * @return model The model for arbitration
   * @details Because the arbitrator always has a model, this API never returns nullptr.
   * @endcond
   */
   const RBAModel* getModel() const;

  /**
   * @cond japanese
   * @brief 調停FWにコンテントとシーンの初期要求をセットする
   * @param contexts 初期状態が表示/出力状態のコンテントのコンテキスト名リスト。
   * コンテキスト名は、以下の形式で表記する。\n
   * "コンテント名/ステート名" または "シーン名"\n\n
   * コンテキストの例：\n
   * TEL/発信中\n
   * TPMS/NORMAL\n
   * 自動運転シーン\n\n
   * コンテントにステートが一つしかない場合、 "/ステート名" は省略可能。 "コンテント名" と表記できる。
   * @details 調停FWオブジェクト作成、または、 clearArbitration() 後、
   * 調停処理開始前に、初期状態が表示/出力状態のコンテント要求、初期状態がONのシーンをセットする。
   * execute()との違いは、調停処理の実施有無である。
   * この関数では、調停処理は行わず、要求のセットのみを行うのに対し、 execute() では調停処理も行う。\n
   * この関数でセットされた要求は、最初の execute() 実行時に調停前情報が要求有りと扱われ調停される。
   * このとき、この関数は調停処理を実施しないので、調停前情報の表示/出力は無しと扱われる。\n
   * 初期要求がなければ調停FWオブジェクト作成後、この関数を呼び出す必要はない。
   * 調停処理開始後、この関数をコールした場合、調停結果に不整合が発生する可能性がある。
   * もし調停FWを初期化したいのであれば、 clearArbitration() を使用すること。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Set initial requirements of contents and scenes
   * @param contexts Context list of contents and scenes requests.
   *
   * Following is the structure of context name.\n
   * *<CONTENT_NAME>* / *<STATE_NAME>* \n\n
   * Example of context name: \n
   * TEL/Calling\n
   * TPMS/NORMAL\n
   * AutoDriveScene\n\n
   * You can omit "/ <STATE_NAME>" if content has only one state.
   * @details After arbitrator creation or calling clearArbitration(),
   * you can set initial state of contents and scenes for first arbitration.
   * This API does not execute arbitration.
   * The information of arbitration result will be empty.
   * Don't call this API after starting arbitration until calling clearArbitration().
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    
   *    std::list<std::string> defaultContents = {
   *      "CONTENT_A/NORMAL",
   *      "CONTENT_B/NORMAL",
   *      "CONTENT_C/NORMAL",
   *      "CONTENT_D/NORMAL",
   *    };
   *    arb->initialize(defaultContents);
   *    std::unique_ptr<RBAResult> result = arb->execute();
   * ```
   */
  void initialize(std::list<std::string>& contexts);

  /**
   * @cond japanese
   * @brief 一つのコンテキストを引き金とした調停処理の実行
   * @param contextName
   * 調停を要求するコンテントまたはシーンのコンテキスト文字列。\n
   * 表示要求/出力要求の場合、”＜コンテント名＞/＜ステート名＞”。\n
   * コンテントにステートが一つしかない場合、＜ステート名＞は省略可能。”＜コンテント名＞”と表記できる。\n
   * シーン要求の場合、”＜シーン名＞”。\n
   * 省略した時は空文字列と扱う。
   * @param require
   * true:表示要求/出力要求/シーンON要求。\n
   * false:表示取り下げ要求/出力取り下げ要求/シーンOFF要求。\n
   * 省略した時はtrueと扱う。
   * @return 調停結果
   * @details
   * 一つのコンテントの表示/出力の調停要求、または、一つのコンテントの表示/出力取り下げ後の調停要求、
   * または、プロパティを持たないシーンのON/OFF後の調停要求に使用する。\n
   * 戻り値として得られる調停結果は、この関数を呼び出すたびに生成されるオブジェクトで、新たに調停処理を実行しても、その結果が変わることはない。\n
   * contextNameで示したコンテキストの表示/出力要求、あるいは、表示/出力取り下げ要求の調停処理を実行する。\n
   * contextNameにシーン名が示された場合は、シーンON/OFF後の調停処理を実行する。\n
   * contextNameに空文字列が示された場合は、調停処理を実行する。\n
   * モデルに定義されていないコンテキストを引数に設定して要求されたとき、調停処理は実施しない。
   * また、返される調停結果の調停結果ステータスはUNKNWON_CONTENT_STATEとなり、その他のプロパティ値は保証しない。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Executes arbitration with one requirement\n
   * @param contextName
   * Context string of arbitration request.\n
   * Display request or sound request : "<CONTENT_NAME>/<STATE_NAME>"\n
   * If the content has only one state, the <STATE> can be omitted.\n
   * \n
   * Scene request : ”<SCENE_NAME>”
   * @param require
   * true : request displaying / outputting content or scene on (default)\n
   * false : withdraw a request or scene off.
   *
   * @return The result of arbitration.
   * @details
   * Execute Arbitration with one requirement of a content or scene without properties. \n
   * The arbitration result as the return value will be generated at every arbitration and
   * will not be changed by another arbitration.
   * \n
   * Context indicates a content state or a scene.
   * If the content or scene is not defined in the model, the arbitration will not executed
   * and the state of the arbitration result will be UNKNWON_CONTENT_STATE.
   * In this case, other property values are undefined.\n
   * If the context is empty, this API just execute arbitration.
   * \n
   * **Exapmle**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    std::unique_ptr<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);
   *    
   *    if(result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {
   *      std::cout << "ERROR: Unknown context" << std::endl;
   *    }
   * ```
   * 
   */
  std::unique_ptr<RBAResult> execute(const std::string& contextName="",
				     bool require=true);

  /**
   * @cond japanese
   * @brief 複数のコンテキストを引き金とした調停処理の実行
   * @param contexts コンテキストのリスト
   * @param require
   * true:表示要求/出力要求/シーンON要求\n
   * false:表示取り下げ要求/出力取り下げ要求/シーンOFF要求\n
   * 実引数を省略した時はtrueと扱う。
   * @return 調停結果
   * @details 複数のコンテントの表示/出力の調停要求、または、複数のコンテントの表示/出力取り下げ後の調停要求、
   * または、複数のシーンのON/OFF後の調停要求。\n
   * シーンとコンテントは混在させて要求することができる。
   * 表示要求と表示取り下げ要求を混在させることはできない。
   * contextsで示したコンテキストの表示/出力要求、あるいは、表示/出力取り下げ要求の調停処理を実行する。\n
   * contextsにシーン名が示された場合は、シーンON/OFF後の調停処理を実行する。\n
   * contextsが空のリストである場合は、調停処理を実行する。\n
   * contextsにモデルに定義されていないコンテキストが含まれていたとき、調停処理は実施しない。
   * また、返される調停結果の調停結果ステータスはUNKNWON_CONTENT_STATEとなり、その他のプロパティ値は保証しない。
   * 調停処理では、contextsリストの先頭から順に要求されたものと扱う。よってcontextsリストの格納順により、異なる調停結果となることがある。
   * @details
   * \n
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Executes arbitration with multiple requirements\n
   * @param contexts List of contexts.
   * @param require
   * true : request displaying / outputting content or scene on (default)\n
   * false : withdraw a request or scene off.
   * @return The result of arbitration.
   * @details
   * \n
   * Execute Arbitration with multiple requirements of contents or scenes. \n
   * Contents and Scenes can be mixed in the list.
   * Display / Outputting request and withdraw request, scene on and scene off request can not be mixed.
   * The arbitration result as the return value will be generated at every arbitration and
   * will not be changed by another arbitration.
   * \n
   * Context indicates a content state or a scene.
   * If the content or scene is not defined in the model, the arbitration will not executed
   * and the state of the arbitration result will be UNKNWON_CONTENT_STATE.\n
   * In this case, other property values are undefined.\n
   * If the context is empty, this API just execute arbitration.
   * \n
   * Request order is the with the list. Beginning of the list will be treated as the first coming request.
   * \n
   * **Exapmle**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    std::list<std::string> contents = {
   *      "CONTENT_A/NORMAL",
   *      "CONTENT_B/NORMAL",
   *      "CONTENT_C/NORMAL",
   *      "CONTENT_D/NORMAL",
   *    };
   *    std::unique_ptr<RBAResult> result = arb->execute(contents, true);
   *    
   *    if(result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {
   *      std::cout << "ERROR: Unknown context" << std::endl;
   *    }
   * ```
   * 
   */
  std::unique_ptr<RBAResult> execute(std::list<std::string>& contexts,
				     bool require=true);

  /**
   * @cond japanese
   * @brief シーンONとシーンのプロパティをセットして調停処理を実行
   * @param sceneName シーン名
   * @param properties プロパティ名と値のリスト
   * @return 調停結果
   * @details
   * sceneNameで示したシーンをONにし、
   * propertiesで指定したプロパティをセットして調停処理を実行する。\n
   * sceneNameが空文字列のとき、調停処理のみを実施し、調停結果を返す。\n
   * sceneNameがモデルに定義されていないシーン名のときは、調停処理は実施しない。
   * また、返される調停結果の調停結果ステータスはUNKNWON_CONTENT_STATEとなり、その他のプロパティ値は保証しない。
   * propertiesにモデルのシーンに定義されていないプロパティ名が含まれていても、調停処理は実施される。
   * @note
   * このAPIではシーンOFFとプロパティを同時にセットできない。
   * シーンOFFとプロパティのセットを同時に実行したいときは、
   * setScene()でシーンOFFとプロパティをセットしてから引数なしの execute(const std::string&,bool)を実行するか、
   * setScene()でプロパティをセットしてから execute(シーン名, false)を実行する。\n
   * \n
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Executes arbitration with a requirement of scene and scene properties.
   * @param sceneName The Scene name of arbitration reauest.\n
   * @param properties The list of pairs of property name and value.
   * @return The result of arbitration.
   * @details
   * \n
   * Sets the scene indicated by sceneName to the property specified
   * by properties, and execute arbitration processing.\n
   * If sceneName is empty, this API just execute arbitration.
   * If the required scene is not defined in the model, the arbitration will not executed
   * and the state of the arbitration result will be UNKNWON_CONTENT_STATE.\n
   * Even If there is a property not defined in the model, the arbitration will be executed.
   * \n
   * @note
   * You cannot set scene off and property at the same time, by this API.\n
   * Use setScene() to set scene off and properties,
   * and then call execute(const std::string&,bool) without specifying arguments.\n
   * Or Use setScene() to set properties,
   * and then call execute(scene name,false).\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    std::list<std::pair<std::string, std::int32_t>> properties;
   *    properties.push_back(std::make_pair("Prop1", 10));
   *    properties.push_back(std::make_pair("Prop2", 20));
   *    std::unique_ptr<RBAResult> result = arb->execute("Scene1", properties);
   *    
   *    if(result->getStatusType() != rba::RBAResultStatusType::SUCCESS) {
   *      std::cout << "ERROR: Unknown context" << std::endl;
   *    }
   * ```
   */
  std::unique_ptr<RBAResult> execute(const std::string& sceneName,
				     std::list<std::pair<std::string,std::int32_t>>& properties);

  /**
   * @cond japanese
   * @brief 調停結果を差し替える
   * @param allocatableName エリア名、または、ゾーン名
   * @param contextName コンテント名/ステート名。\nコンテントにステートが一つしかない場合、＜ステート名＞は省略可能。
   * @return 調停結果
   * @details
   * 前回の調停結果のエリアまたはゾーンの表示/出力コンテントステートを、指定したコンテントステートに変更（差し替え）した調停結果を返す。\n
   * ここで指定したコンテントステートは以後の調停処理において要求状態と扱わる。\n
   * この関数の処理では、調停負け時アクション判定処理と制御実行式の評価を行い、制約式のチェックは行わない。
   * よって、制約式を満たさない場合も、指定したコンテントステートに差し替える。\n
   * また、モデルでの表示コンテント定義において<表示可能なエリア>に定義のないエリアへの
   * コンテントステートの差し替えが要求された場合もコンテントステートを差し替える。これは、音声コンテントとゾーンの場合も同様である。\n
   * この関数ではViewActionの生成は行わず、調停結果のViewActionは空になる。\n
   * モデルで未定義のallocatableName、または、contextNameを指定した場合、
   * 調停結果ステータスをUNKNWON_CONTENT_STATEに変更した、前回の調停結果を返す\n
   * allocatableNameで指定したエリアが隠蔽、または、ゾーンがミュート、あるいは減衰の場合は、それらの状態を保持する。
   * @deprecated
   * 差し替えにより、表示/出力状態とルールが矛盾した状態になる可能性がある。\n
   * この関数は極力使用せず、execute()にて調停処理を実施することを推奨する。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Replaces the result of arbitration
   * @param allocatableName area or zone name
   * @param contextName Context string of arbitration request.
   * @return The result of arbitration.
   * @details
   * \n
   * Replace allocated a content state to area or zone of the last arbitration result.\n
   * If the allocatableName or contextName is undefined, return the errror
   * code from the method getStatusType() of result.\n
   * If the contextName is non-active, activate the content request.
   * This API execute the "Request handling on lost" process and the
   * "Execution expression" process, and doesn't execute the check of
   * constraint expression process.
   * Therefore, this API can lead the result that does not satisfy the constraints\n
   * If the specified area or zone by allocatableName is hidden, mute or
   * attenuated, these statuses will be kept.
   * @deprecated Because there is a possibility that the result does not satisfy
   * the constraints, please use execute()
   * instead of this API.\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    std::unique_ptr<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);
   *    std::unique_ptr<RBAResult> result_replaced = arb->setResultContentState("AREA_A", "CONTENT_B/NORMAL");
   *
   *    if(result_replaced->getStatusType() != rba::RBAResultStatusType::SUCCESS) {
   *      std::cout << "ERROR" << std::endl;
   *    }
   * ```
   */
  std::unique_ptr<RBAResult>
  setResultContentState(const std::string& allocatableName,
			const std::string& contextName);

  /**
   * @cond japanese
   * @brief 調停結果を差し戻す
   * @return 調停結果
   * @details
   * 調停結果を一つ前の状態に戻し、直前の execute()、または、 setResultContentState()を無かったことにする。
   * この関数は一つ前の調停結果を返すが、このときの、ViewActionは空になる。\n
   * この関数は連続した実行を禁止しており、続けて２回以上の呼び出しはエラーとなる。
   * また、調停FWオブジェクト生成後、調停処理を行わずに実行した場合もエラーとなる。
   * エラーの場合、調停結果ステータスにCANCEL_ERRORをセットした調停結果を返す。\n
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Cancel last arbitration
   * @return The result of arbitration.
   * @details
   * \n
   * Cancel last arbitration and restore internal state immediately.\n
   * This API returns the restored result but the ViewActions will be empty.\n
   * Do not execute this function more than once continuously. In that case,
   * an error occurs.\n
   * Even when executed without performing arbitration processing,
   * an error occurs.\n
   * In case of error, the status of the arbitration result is set to 
   * CANCEL_ERROR.\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    RBAJsonParser parser;
   *    rba::RBAModel* model = parser.parse(JSONFILE_PATH);
   *    rba::RBAArbitrator* arb = new rba::RBAArbitrator(model);
   *    std::unique_ptr<RBAResult> result = arb->execute("CONTENT_A/NORMAL", true);
   *    std::unique_ptr<RBAResult> result_back = arb->cancelArbitration()
   *
   *    if(result_replaced->getStatusType() != rba::RBAResultStatusType::SUCCESS) {
   *      std::cout << "ERROR" << std::endl;
   *    }
   * ```
   */
  std::unique_ptr<RBAResult> cancelArbitration();

  /**
   * @cond japanese
   * @brief 調停処理の内部状態をクリアする
   * @details
   * 調停FWオブジェクトを初期状態に戻す。
   * @note
   * 単体テスト時の初期状態設定などに使用する。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Clear internal states of arbitration.
   * @details
   * \n
   * Initialize internal states of arbitration (ex. Previous arbitration
   * result, request of content states, etc...) and set to the initial state.\n
   * \n
   * @note
   * This API is intended for setting up initial state of unit tests.\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    std::unique_ptr<RBAResult> result1 = arb->execute("CONTENT_A/NORMAL", true);
   *    std::unique_ptr<RBAResult> result2 = arb->execute("CONTENT_B/NORMAL", true);
   *    // reset display requests
   *    arb->clearArbitration();
   *    std::unique_ptr<RBAResult> result2 = arb->execute("CONTENT_C/NORMAL", true);
   *    std::unique_ptr<RBAResult> result3 = arb->execute("CONTENT_D/NORMAL", true);

   *
   * ```
   */
  void clearArbitration();

  /**
   * @cond japanese
   * @brief シーンON/OFFとプロパティをセットする
   * @param sceneName シーン名
   * @param require
   * true:シーンON\n
   * false:シーンOFF\n
   * 実引数を省略した時はtrueと扱う。
   * @param properties プロパティ名と値のリスト
   * @return
   * true:シーンのセットに成功\n
   * false:シーンのセットに失敗
   * @details
   * sceneNameで示したシーンのON/OFF状態をセットし、propertiesで指定したプロパティをセットする。調停処理は実行しない。
   * sceneNameにモデル未定義のシーン名を指定した場合はfalseを返す。
   * @note
   * 単体テスト時の初期状態設定やプロパティ付きグローバルシーンの設定などに使用する。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Sets scene ON/OFF requests and properties.
   * @param sceneName The Scene name of arbitration reauest.\n
   * @param require true : Valid request.\n
   * false : Invalid request.
   * @param properties The pair of property name and value.\n
   * @return true: Success\n
   * @return false: Unknown scene\n
   * @details
   * \n
   * Sets the scene indicated by sceneName to the property specified
   * by properties, and without execute arbitration processing.\n
   * Returns true if the scene set succeeded. If an unknown scene name is
   * specified, false is returned.\n
   * \n
   * @note
   * This API is intended for setting up initial state of unit tests\n
   * or setting global scene and scene properties.\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    std::list<std::pair<std::string, std::int32_t>> props;
   *    props.push_back(std::make_pair("PropertyA", 10);
   *    props.push_back(std::make_pair("PropertyB", -3);
   *    res = arb->setScene("SCENE_A", true, props);
   *    if(res == false) {
   *        // Unknwon scene
   *    }
   * ```
   */
  bool setScene(const std::string& sceneName, bool require,
		std::list<std::pair<std::string, std::int32_t>>& properties);

  /**
   * @cond japanese
   * @brief コンテントステートの表示/出力要求、または、コンテントステートの表示/出力取り下げ要求、または、シーンON/OFFをセットする。
   * @param contextName
   * 調停要求のコンテキスト文字列\n
   * 表示/出力要求の場合、”＜コンテント名＞/＜ステート名＞”。\n
   * コンテントにステートが一つしかない場合、＜ステート名＞は省略可能。\n
   * シーン要求の場合、”＜シーン名＞”。
   * @param require
   * true:表示要求/出力要求/シーンON\n
   * false:表示取り下げ要求/出力取り下げ要求/シーンOFF
   * @return true:成功\n
   * @return false:失敗 要求されたコンテキストがモデルに定義されていない
   * @details
   * contextNameにコンテントステートが示された場合は、表示/出力要求、あるいは、表示/出力取り下げ要求をセットする。\n
   * contextNameにシーン名が示された場合は、シーンON/OFFをセットする。\n
   * 調停処理は実行しない。
   * @note
   * 単体テスト時の初期状態設定などに使用する。\n
   * initialize()は要求をONにする機能しか持たないが、本処理では要求をOFFにすることができる。
   * 単体テストの初期化設定で、個別の要求のON/OFFに使用する。\n
   * \n
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Sets content requests or scene ON/OFF request.
   * @param contextName Context string of arbitration request.\n
   * @param require
   * true : request displaying / outputting content or scene on (default)\n
   * false : withdraw a request or scene off.
   * @return true: Success\n
   * @return false: Unknown context\n
   * @details
   * \n
   * Sets a display request for the context without arbitration.\n
   * Returns true if the request setting is succeeded. If an unknown context
   * name is specified, false is returned.\n
   * \n
   * @note
   * This API is intended for setting up initial state of unit tests.\n
   * While initialize() has only the function to turn on the request,
   * this API can turn off the request. It is used for switch of each
   * requests when initialization setting of unit test.\n
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    res = arb->setContentState("ContentA/NORMAL", true);
   *    if(res == false) {
   *        // Unknwon context
   *    }
   * ```
   */
  bool setContentState(const std::string& contextName, bool require);

  /**
   * @cond japanese
   * @brief エリア/ゾーンに表示/出力するコンテントステートをセットする
   * @param allocatableName エリア名、または、ゾーン名
   * @param contextName ”＜コンテント名＞/＜ステート名＞”。\n
   * コンテントに状態が一つしかない場合、＜ステート名＞は省略可能
   * @return
   * true:成功\n
   * false:失敗
   * @details
   * 前回の調停結果のエリアまたはゾーンの表示/出力コンテントステートを、指定したコンテントステートに変更する。
   * ここで指定したコンテントステートは以後の調停処理において要求状態と扱われる。
   * この関数では調停処理は行わない。よって、制約式を満たさない場合も、指定したコンテントステートに差し替える。\n
   * また、モデルでの表示コンテント定義において<表示可能なエリア>に定義のないエリアへの
   * コンテントステートの差し替えが要求された場合もコンテントステートを差し替える。これは、音声コンテントとゾーンの場合も同様である。\n
   * モデルで未定義のallocatableName、または、contextNameを指定した場合、falseを返す\n
   * allocatableNameで指定したエリアが隠蔽、または、ゾーンがミュート、あるいは減衰の場合は、それらの状態を保持する。
   * @note
   * 単体テスト時の初期状態設定などに使用する。\n
   * setResultContentState()ではコンテントステートの割り当ての他、
   * 調停負け時アクション判定処理と制御実行式の評価を行なっているのに対し、
   * 本処理ではコンテントステートの割り当てのみを行う。\n
   * @deprecated
   * 制約に矛盾した状態になる可能性もあるため、単体テスト以外では使用しないことを推奨する。
   * @details
   * **使用例：**
   * @endcond
   *
   * @cond english
   * @brief Allocates content state to area or zone.
   * @param allocatableName Name of area or zone
   * @param contextName Context string of content state.\n
   *  contextName : "<CONTENT_NAME>/<STATE_NAME>"\n
   * If the content has only one state, the <STATE> can be omitted.\n
   * \n
   * @return true: Success\n
   * @return false: Unknown area, zone or context\n
   * @details
   * \n
   * Allocates the content state to the area or zone. Arbitration and
   * post arbitration will not be executed.\n
   * The display / outputting request of the specified content state will be active.
   * The statuses of hidden, mute and attenuated will not be changed.\n
   * Returns true if the request setting is succeeded. If an unknown context
   * name is specified, false is returned.\n
   *
   * @note
   * This API is intended for setting up initial state of unit tests.\n
   * In setResultContentState(), in addition to content state assignment,
   * evaluation of the action determination process at the time of arbitration
   * losing and control execution expression is performed, whereas in this
   * API only content state assignment is performed.\n
   * \n
   * @deprecated
   * Since there is a possibility of contradiction with the
   * constraint, it is recommended not to use it except unit test.
   * \n
   * @details
   * **Example**
   * @endcond
   *
   * ```
   *    res = arb->setAllocatableResult("AreaA", "ContentA/NORMAL");
   *    if(res == false) {
   *        // Unknwon area, zone or context
   *    }
   * ```
   */
  bool setAllocatableResult(const std::string& allocatableName,
			    const std::string& contextName);
  // internal {
#ifdef RBA_USE_LOG
  RBAArbitrator(RBAModel* newModel, RBALogManager* logManager);
#endif
  bool evaluate(RBAExpression* expression);
  const RBARuleObject* evaluateObject(RBAExpression* expression);
  int32_t evaluateValue(RBAExpression* expression);

  // }

private:
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable:4251)
#endif
#ifdef _MSC_VER
#pragma warning(pop)
#endif

private:
  bool isValidContext(const std::string& context);
  bool isValidContext(std::list<std::string>& contexts);
  bool setRequestData(
      const std::string& context, bool require,
      std::list<std::pair<std::string, std::int32_t>>* const properties = nullptr,
      std::uint32_t syncIndex = 0xFFFFU);
  void setRequestData(const RBAContentState* state, bool require);
  void setRequestData(const RBAContent* const content, bool require);
  void setActive(const RBASceneImpl* const scene, const bool require);
  void setSceneProperty(const RBAAbstractProperty* const prop, const std::int32_t value);
  void setRequestData(std::list<std::string>& contexts, const bool require);

#ifdef RBA_USE_LOG
  void checkAllConstraints();
#endif
  void updateResult();
  void checkCancelContent() const;
  void createResultData();

public:
  bool satisfiesConstraints() const;

private:
  std::unique_ptr<RBAResult> arbitrateMain();
  void arbitrate(std::list<RBAAllocatable*>& allocatables);
  void arbitrateAllocatable(RBAAllocatable* allocatable,
                            std::set<const RBAAllocatable*>& revisited,
                            const std::int32_t nest, RBAAffectInfo* const affectInfo,
                            RBARollbacker* const parentRollbacker);

  bool sortContentStates(const RBAAllocatable* const allocatable,
                         std::list<const RBAContentState*>& states) const;
  void postArbitrate();
  void changeContentStateCancelWithPolicy(const RBAContentState* const state);
  void collectRevisitAllocatable(
      std::list<const RBAAllocatable*>* const totalRevisitAllocatables,
      RBAAllocatable*& allocatable,
      std::list<RBAConstraintImpl*>& falseConstraints,
      std::set<const RBAAllocatable*>& revisited);

  static std::int32_t getViewActionPriority(const RBAViewActionType viewActionType);
  static bool compareViewAction(const std::unique_ptr<RBAViewAction>& lhs,
                                const std::unique_ptr<RBAViewAction>& rhs);

public:
  RBAResultImpl* getResult() const;  /// rba_toolで使用する
  bool isCancel(const RBAContentState* const state) const;

private:
  void differenceArbitrate();
  bool checkConstraints(std::list<RBAConstraintImpl*>& constraints,
                        std::list<RBAConstraintImpl*>& falseConstraints,
                        const RBAAllocatable* const allocatable);
  bool checkConstraintAndReArbitrate(RBAAllocatable* allocatable,
                                     std::set<const RBAAllocatable*>& revisited,
                                     const std::int32_t nest,
                                     RBAAffectInfo* const affectInfo,
                                     RBARollbacker* const parentRollbacker,
                                     std::list<RBAConstraintImpl*>& constraints,
                                     bool * const isSkipped, const bool isFinal);
  void setCancel(const RBAContentState* const state, const bool checked);
  void getSortedContentStates(
      const RBAAllocatable* const allocatable,
      std::list<const RBAContentState*>& contentStates) const;

#ifdef RBA_USE_LOG
  // ログ出力
  void logRequestArbitration();
  void logPreResultArbitration();
  void logRequestForCoverage();
  void logResultArbitration();
  void logResultForCoverage();
  void setLogToResult();
#endif

public:
  std::set<const RBAContentState*>& getCancelChecked();
  std::unique_ptr<RBAResultImpl>& getResultRef() const;
  void setResult(std::unique_ptr<RBAResultImpl> result);
  std::unique_ptr<RBAResultSet>& getNextResultSet();
  void setNextResultSet(std::unique_ptr<RBAResultSet> nextResultSet);
  std::unique_ptr<RBAResultSet>& getBackupResultSet();
  void setBackupResultSet(std::unique_ptr<RBAResultSet> backupResultSet);
  std::unique_ptr<RBAResultSet>& getReservedResultSet();
  void setReservedResultSet(std::unique_ptr<RBAResultSet> reservedResultSet);
  std::recursive_mutex& getMutex() const;
#ifdef RBA_USE_LOG
  void setSimulationMode(bool simulationMode);
#endif
  std::deque<std::unique_ptr<RBARequestQueMember>>& getRequestQue();

private:
  RBAModelImpl* model_ {nullptr};
  std::set<const RBAContentState*> cancelChecked_;

  mutable std::unique_ptr<RBAResultImpl> result_;
  // 次の調停でCurrentResultSetとして使用するResultSet
  std::unique_ptr<RBAResultSet> nextResultSet_;
  // 次の調停でPreviousResultSetとして使用するResultSet
  std::unique_ptr<RBAResultSet> backupResultSet_;
  // cancelArbitration()でCurrentResultSetとして使用するResultSet
  std::unique_ptr<RBAResultSet> reservedResultSet_;
  // satisfiesConstraints()でCurrentResultSetとして使用するResultSet
  std::unique_ptr<RBAResultSet> resultSetForSatisfiesConstraints_;
  mutable std::recursive_mutex mutex_;
#ifdef RBA_USE_LOG
  bool simulationMode_ = false;
#endif
  std::deque<std::unique_ptr<RBARequestQueMember>> requestQue_;

public:
  void setModel(RBAModelImpl* const newModel);
};

}

#endif
