#Request#C,on,A1,NORMAL,1
#Request#C,off,A2,NORMAL,0
#Request#C,off,B1,NORMAL,0
#Request#C,off,C1,NORMAL,0
#Request#C,off,D1,NORMAL,0
#Request#C,off,E1,NORMAL,0
#Request#C,off,F1,NORMAL,0
#Request#C,off,G1,NORMAL,0
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	skip
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#CanceledRequest#A1,NORMAL,f
#CanceledRequest#A2,NORMAL,f
#CanceledRequest#B1,NORMAL,f
#CanceledRequest#C1,NORMAL,f
#CanceledRequest#D1,NORMAL,f
#CanceledRequest#E1,NORMAL,f
#CanceledRequest#F1,NORMAL,f
#CanceledRequest#G1,NORMAL,f
#Result#A,A,A1
#Result#A,B,
#Result#A,C,
#Result#A,D,
#Result#A,E,
#Result#A,F,
#Result#A,G,
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#PrevResult#A,A,A1,NORMAL
#Request#C,on,A1,NORMAL,1
#Request#C,on,A2,NORMAL,2
#Request#C,off,B1,NORMAL,0
#Request#C,off,C1,NORMAL,0
#Request#C,off,D1,NORMAL,0
#Request#C,off,E1,NORMAL,0
#Request#C,off,F1,NORMAL,0
#Request#C,off,G1,NORMAL,0
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#CanceledRequest#A1,NORMAL,f
#CanceledRequest#A2,NORMAL,f
#CanceledRequest#B1,NORMAL,f
#CanceledRequest#C1,NORMAL,f
#CanceledRequest#D1,NORMAL,f
#CanceledRequest#E1,NORMAL,f
#CanceledRequest#F1,NORMAL,f
#CanceledRequest#G1,NORMAL,f
#Result#A,A,A2
#Result#A,B,
#Result#A,C,A2
#Result#A,D,
#Result#A,E,
#Result#A,F,
#Result#A,G,
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#PrevResult#A,A,A2,NORMAL
#PrevResult#A,C,A2,NORMAL
#Request#C,on,A1,NORMAL,1
#Request#C,on,A2,NORMAL,2
#Request#C,off,B1,NORMAL,0
#Request#C,off,C1,NORMAL,0
#Request#C,off,D1,NORMAL,0
#Request#C,on,E1,NORMAL,3
#Request#C,off,F1,NORMAL,0
#Request#C,off,G1,NORMAL,0
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	f
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#CanceledRequest#A1,NORMAL,f
#CanceledRequest#A2,NORMAL,f
#CanceledRequest#B1,NORMAL,f
#CanceledRequest#C1,NORMAL,f
#CanceledRequest#D1,NORMAL,f
#CanceledRequest#E1,NORMAL,f
#CanceledRequest#F1,NORMAL,f
#CanceledRequest#G1,NORMAL,f
#Result#A,A,A2
#Result#A,B,
#Result#A,C,A2
#Result#A,D,
#Result#A,E,E1
#Result#A,F,
#Result#A,G,
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	t
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#PrevResult#A,A,A2,NORMAL
#PrevResult#A,C,A2,NORMAL
#PrevResult#A,E,E1,NORMAL
#Request#C,on,A1,NORMAL,1
#Request#C,on,A2,NORMAL,2
#Request#C,off,B1,NORMAL,0
#Request#C,off,C1,NORMAL,0
#Request#C,off,D1,NORMAL,0
#Request#C,on,E1,NORMAL,3
#Request#C,on,F1,NORMAL,4
#Request#C,off,G1,NORMAL,0
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	f
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#CanceledRequest#A1,NORMAL,f
#CanceledRequest#A2,NORMAL,f
#CanceledRequest#B1,NORMAL,f
#CanceledRequest#C1,NORMAL,f
#CanceledRequest#D1,NORMAL,f
#CanceledRequest#E1,NORMAL,f
#CanceledRequest#F1,NORMAL,f
#CanceledRequest#G1,NORMAL,f
#Result#A,A,A2
#Result#A,B,
#Result#A,C,A2
#Result#A,D,
#Result#A,E,E1
#Result#A,F,
#Result#A,G,
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	t
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#PrevResult#A,A,A2,NORMAL
#PrevResult#A,C,A2,NORMAL
#PrevResult#A,E,E1,NORMAL
#Request#C,on,A1,NORMAL,1
#Request#C,on,A2,NORMAL,2
#Request#C,off,B1,NORMAL,0
#Request#C,off,C1,NORMAL,0
#Request#C,off,D1,NORMAL,0
#Request#C,on,E1,NORMAL,3
#Request#C,on,F1,NORMAL,4
#Request#C,on,G1,NORMAL,5
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	skip
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	skip
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	skip
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	skip
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	skip
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	skip
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	skip
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	skip
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	f
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	f
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	t
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	f
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A2}	t
#Constraint#EXPRESSION	->#right->#leftExists#0==	D.allocatedContent() == E1	f
#Constraint#EXPRESSION	->#right->#leftExists#1==	E.allocatedContent() == E1	t
#Constraint#EXPRESSION	->#right->#leftExists	Exists {D, E} { x |x.allocatedContent() == E1}	t
#Constraint#EXPRESSION	->#right->#right.isHidden()	F.isHidden()	t
#Constraint#EXPRESSION	->#right->	(Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden())	t
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A2} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	t
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	f
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	t
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	t
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
#CanceledRequest#A1,NORMAL,f
#CanceledRequest#A2,NORMAL,f
#CanceledRequest#B1,NORMAL,f
#CanceledRequest#C1,NORMAL,f
#CanceledRequest#D1,NORMAL,f
#CanceledRequest#E1,NORMAL,f
#CanceledRequest#F1,NORMAL,f
#CanceledRequest#G1,NORMAL,f
#Result#A,A,A1
#Result#A,B,
#Result#A,C,A2
#Result#A,D,
#Result#A,E,E1
#Result#A,F,F1
#Result#A,G,G1
#Constraint#START,HA1208_LetStatement_SameName1,t
#Constraint#EXPRESSION	->#leftExists#0==	B.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists#1==	C.allocatedContent() == A1	f
#Constraint#EXPRESSION	->#leftExists	Exists {B, C} { x |x.allocatedContent() == A1}	f
#Constraint#EXPRESSION	->	(Exists {B, C} { x |x.allocatedContent() == A1} -> (Exists {D, E} { x |x.allocatedContent() == E1} -> F.isHidden()))	t
#Constraint#END
#Constraint#START,HA1208_LetStatement_SameName2,t
#Constraint#EXPRESSION	->#left.isVisible()	G1.isVisible()	t
#Constraint#EXPRESSION	->#right!#==	A.allocatedContent() == A2	f
#Constraint#EXPRESSION	->#right!	!A.allocatedContent() == A2	t
#Constraint#EXPRESSION	->	(G1.isVisible() -> !A.allocatedContent() == A2)	t
#Constraint#END
----Request Information----
Allocatable Count:7
  Area[A] policy[DEFAULT] visibility[3]
  Area[B] policy[DEFAULT] visibility[2]
  Area[C] policy[DEFAULT] visibility[1]
  Area[D] policy[DEFAULT] visibility[0]
  Area[E] policy[DEFAULT] visibility[0]
  Area[F] policy[DEFAULT] visibility[0]
  Area[G] policy[DEFAULT] visibility[0]
ContentState Count:8
  ViewContent[A1::NORMAL] priority[10] isActive[true] order[1]
  ViewContent[A2::NORMAL] priority[11] isActive[false] order[0]
  ViewContent[B1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[C1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[D1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[E1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[F1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[G1::NORMAL] priority[10] isActive[false] order[0]
Scene Count:0
Constraint Count:2
  Constraint[HA1208_LetStatement_SameName1] Expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] runtime[true]
  Constraint[HA1208_LetStatement_SameName2] Expression[(letX.isVisible() -> !A.allocatedContent() == A2)] runtime[true]
----Request Information----
Allocatable Count:7
  Area[A] policy[DEFAULT] visibility[3]
  Area[B] policy[DEFAULT] visibility[2]
  Area[C] policy[DEFAULT] visibility[1]
  Area[D] policy[DEFAULT] visibility[0]
  Area[E] policy[DEFAULT] visibility[0]
  Area[F] policy[DEFAULT] visibility[0]
  Area[G] policy[DEFAULT] visibility[0]
ContentState Count:8
  ViewContent[A1::NORMAL] priority[10] isActive[true] order[1]
  ViewContent[A2::NORMAL] priority[11] isActive[true] order[2]
  ViewContent[B1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[C1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[D1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[E1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[F1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[G1::NORMAL] priority[10] isActive[false] order[0]
Scene Count:0
Constraint Count:2
  Constraint[HA1208_LetStatement_SameName1] Expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] runtime[true]
  Constraint[HA1208_LetStatement_SameName2] Expression[(letX.isVisible() -> !A.allocatedContent() == A2)] runtime[true]
----Request Information----
Allocatable Count:7
  Area[A] policy[DEFAULT] visibility[3]
  Area[B] policy[DEFAULT] visibility[2]
  Area[C] policy[DEFAULT] visibility[1]
  Area[D] policy[DEFAULT] visibility[0]
  Area[E] policy[DEFAULT] visibility[0]
  Area[F] policy[DEFAULT] visibility[0]
  Area[G] policy[DEFAULT] visibility[0]
ContentState Count:8
  ViewContent[A1::NORMAL] priority[10] isActive[true] order[1]
  ViewContent[A2::NORMAL] priority[11] isActive[true] order[2]
  ViewContent[B1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[C1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[D1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[E1::NORMAL] priority[10] isActive[true] order[3]
  ViewContent[F1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[G1::NORMAL] priority[10] isActive[false] order[0]
Scene Count:0
Constraint Count:2
  Constraint[HA1208_LetStatement_SameName1] Expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] runtime[true]
  Constraint[HA1208_LetStatement_SameName2] Expression[(letX.isVisible() -> !A.allocatedContent() == A2)] runtime[true]
----Request Information----
Allocatable Count:7
  Area[A] policy[DEFAULT] visibility[3]
  Area[B] policy[DEFAULT] visibility[2]
  Area[C] policy[DEFAULT] visibility[1]
  Area[D] policy[DEFAULT] visibility[0]
  Area[E] policy[DEFAULT] visibility[0]
  Area[F] policy[DEFAULT] visibility[0]
  Area[G] policy[DEFAULT] visibility[0]
ContentState Count:8
  ViewContent[A1::NORMAL] priority[10] isActive[true] order[1]
  ViewContent[A2::NORMAL] priority[11] isActive[true] order[2]
  ViewContent[B1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[C1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[D1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[E1::NORMAL] priority[10] isActive[true] order[3]
  ViewContent[F1::NORMAL] priority[10] isActive[true] order[4]
  ViewContent[G1::NORMAL] priority[10] isActive[false] order[0]
Scene Count:0
Constraint Count:2
  Constraint[HA1208_LetStatement_SameName1] Expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] runtime[true]
  Constraint[HA1208_LetStatement_SameName2] Expression[(letX.isVisible() -> !A.allocatedContent() == A2)] runtime[true]
----Request Information----
Allocatable Count:7
  Area[A] policy[DEFAULT] visibility[3]
  Area[B] policy[DEFAULT] visibility[2]
  Area[C] policy[DEFAULT] visibility[1]
  Area[D] policy[DEFAULT] visibility[0]
  Area[E] policy[DEFAULT] visibility[0]
  Area[F] policy[DEFAULT] visibility[0]
  Area[G] policy[DEFAULT] visibility[0]
ContentState Count:8
  ViewContent[A1::NORMAL] priority[10] isActive[true] order[1]
  ViewContent[A2::NORMAL] priority[11] isActive[true] order[2]
  ViewContent[B1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[C1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[D1::NORMAL] priority[10] isActive[false] order[0]
  ViewContent[E1::NORMAL] priority[10] isActive[true] order[3]
  ViewContent[F1::NORMAL] priority[10] isActive[true] order[4]
  ViewContent[G1::NORMAL] priority[10] isActive[true] order[5]
Scene Count:0
Constraint Count:2
  Constraint[HA1208_LetStatement_SameName1] Expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] runtime[true]
  Constraint[HA1208_LetStatement_SameName2] Expression[(letX.isVisible() -> !A.allocatedContent() == A2)] runtime[true]
----Previous Result Information----
Allocatable TotalCount:7
  Area[A] Content[null] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[null] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[null] hidden[false]
  Area[F] Content[null] hidden[false]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] active[false]
  ViewContent[A2] visible[false] active[false]
  ViewContent[B1] visible[false] active[false]
  ViewContent[C1] visible[false] active[false]
  ViewContent[D1] visible[false] active[false]
  ViewContent[E1] visible[false] active[false]
  ViewContent[F1] visible[false] active[false]
  ViewContent[G1] visible[false] active[false]
----Previous Result Information----
Allocatable TotalCount:7
  Area[A] Content[A1::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[null] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[null] hidden[false]
  Area[F] Content[null] hidden[false]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[true] active[true]
    allocated Area[A]
  ViewContent[A2] visible[false] active[false]
  ViewContent[B1] visible[false] active[false]
  ViewContent[C1] visible[false] active[false]
  ViewContent[D1] visible[false] active[false]
  ViewContent[E1] visible[false] active[false]
  ViewContent[F1] visible[false] active[false]
  ViewContent[G1] visible[false] active[false]
----Previous Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[null] hidden[false]
  Area[F] Content[null] hidden[false]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] active[true]
  ViewContent[A2] visible[true] active[true]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] active[false]
  ViewContent[C1] visible[false] active[false]
  ViewContent[D1] visible[false] active[false]
  ViewContent[E1] visible[false] active[false]
  ViewContent[F1] visible[false] active[false]
  ViewContent[G1] visible[false] active[false]
----Previous Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[E1::NORMAL] hidden[false]
  Area[F] Content[null] hidden[true]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] active[true]
  ViewContent[A2] visible[true] active[true]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] active[false]
  ViewContent[C1] visible[false] active[false]
  ViewContent[D1] visible[false] active[false]
  ViewContent[E1] visible[true] active[true]
    allocated Area[E]
  ViewContent[F1] visible[false] active[false]
  ViewContent[G1] visible[false] active[false]
----Previous Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[E1::NORMAL] hidden[false]
  Area[F] Content[F1::NORMAL] hidden[true]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] active[true]
  ViewContent[A2] visible[true] active[true]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] active[false]
  ViewContent[C1] visible[false] active[false]
  ViewContent[D1] visible[false] active[false]
  ViewContent[E1] visible[true] active[true]
    allocated Area[E]
  ViewContent[F1] visible[false] active[true]
    allocated Area[F]
  ViewContent[G1] visible[false] active[false]
----Arbitrate----
Area[A] check start
  Content[A2] is not Active skip
  Content[A1::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[A] displays Content[A1::NORMAL] hidden[false]

Area[B] check start
  Content[B1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[B] displays Content[null] hidden[false]

Area[C] check start
  Content[A2] is not Active skip
  Content[C1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

  check online constraints to confirm area hidden state
Area[C] displays Content[null] hidden[false]

Area[D] check start
  Content[D1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

  check online constraints to confirm area hidden state
Area[D] displays Content[null] hidden[false]

Area[E] check start
  Content[E1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

  check online constraints to confirm area hidden state
Area[E] displays Content[null] hidden[false]

Area[F] check start
  Content[F1] is not Active skip
  Content[null] check online constraints start
  check online constraints to confirm area hidden state
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

Area[F] displays Content[null] hidden[false]

Area[G] check start
  Content[G1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[G] displays Content[null] hidden[false]

----Arbitrate----
Area[A] check start
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[A] displays Content[A2::NORMAL] hidden[false]

Area[B] check start
  Content[B1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[B] displays Content[null] hidden[false]

Area[C] check start
  Content[C1] is not Active skip
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[C] displays Content[A2::NORMAL] hidden[false]

Area[D] check start
  Content[D1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[D] displays Content[null] hidden[false]

Area[E] check start
  Content[E1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {D, E} { x |x.allocatedContent() == letX}] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

  check online constraints to confirm area hidden state
Area[E] displays Content[null] hidden[false]

Area[F] check start
  Content[F1] is not Active skip
  Content[null] check online constraints start
  check online constraints to confirm area hidden state
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {D, E} { x |x.allocatedContent() == letX}] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

Area[F] displays Content[null] hidden[false]

Area[G] check start
  Content[G1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[G] displays Content[null] hidden[false]

----Arbitrate----
Area[A] check start
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[A] displays Content[A2::NORMAL] hidden[false]

Area[B] check start
  Content[B1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[B] displays Content[null] hidden[false]

Area[C] check start
  Content[C1] is not Active skip
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[C] displays Content[A2::NORMAL] hidden[false]

Area[D] check start
  Content[D1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[D] displays Content[null] hidden[false]

Area[E] check start
  Content[E1::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[E] displays Content[E1::NORMAL] hidden[false]

Area[F] check start
  Content[F1] is not Active skip
  Content[null] check online constraints start
  check online constraints to confirm area hidden state
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false

Area[F] change hidden
Area[F] displays Content[null] hidden[true]

Area[G] check start
  Content[G1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[G] displays Content[null] hidden[false]

----Arbitrate----
Area[A] check start
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[A] displays Content[A2::NORMAL] hidden[false]

Area[B] check start
  Content[B1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[B] displays Content[null] hidden[false]

Area[C] check start
  Content[C1] is not Active skip
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[C] displays Content[A2::NORMAL] hidden[false]

Area[D] check start
  Content[D1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[D] displays Content[null] hidden[false]

Area[E] check start
  Content[E1::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[E] displays Content[E1::NORMAL] hidden[false]

Area[F] check start
  Content[F1::NORMAL] check online constraints start
  check online constraints to confirm area hidden state
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false

Area[F] change hidden
Area[F] displays Content[F1::NORMAL] hidden[true]

Area[G] check start
  Content[G1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[G] displays Content[null] hidden[false]

----Arbitrate----
Area[A] check start
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is before arbitrate skip
      Allocatable[A] has Allocated Content[A2]
      [A.allocatedContent() == A2] true
      [!A.allocatedContent() == A2] false
      [(letX.isVisible() -> !A.allocatedContent() == A2)] before arbitrate skip
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] before arbitrate skip

  check online constraints to confirm area hidden state
Area[A] displays Content[A2::NORMAL] hidden[false]

Area[B] check start
  Content[B1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {B, C} { x |x.allocatedContent() == letX}] before arbitrate skip
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[B] displays Content[null] hidden[false]

Area[C] check start
  Content[C1] is not Active skip
  Content[A2::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[C] displays Content[A2::NORMAL] hidden[false]

Area[D] check start
  Content[D1] is not Active skip
  Content[null] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] is before arbitrate skip
      [x.allocatedContent() == letX] before arbitrate skip
      [Exists {D, E} { x |x.allocatedContent() == letX}] before arbitrate skip
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[D] displays Content[null] hidden[false]

Area[E] check start
  Content[E1::NORMAL] check online constraints start
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] before arbitrate skip
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] before arbitrate skip
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] before arbitrate skip

  check online constraints to confirm area hidden state
Area[E] displays Content[E1::NORMAL] hidden[false]

Area[F] check start
  Content[F1::NORMAL] check online constraints start
  check online constraints to confirm area hidden state
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] false

Area[F] change hidden
Area[F] displays Content[F1::NORMAL] hidden[true]

Area[G] check start
  Content[G1::NORMAL] check online constraints start
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1::NORMAL] is Visible
      Allocatable[A] has Allocated Content[A2]
      [A.allocatedContent() == A2] true
      [!A.allocatedContent() == A2] false
      [(letX.isVisible() -> !A.allocatedContent() == A2)] false
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] false

    Area[A] revisit allocatable check start
      Content[A2::NORMAL] check online constraints start
        constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
          Allocatable[A] has Allocated Content[A2]
          let letX = A.allocatedContent() = A2
          Allocatable[B] has no Allocated Content
          [x.allocatedContent() == letX] false
          Allocatable[A] has Allocated Content[A2]
          let letX = A.allocatedContent() = A2
          Allocatable[C] has Allocated Content[A2]
          [x.allocatedContent() == letX] true
          [Exists {B, C} { x |x.allocatedContent() == letX}] true
          let letX = E1 = E1
          Allocatable[D] has no Allocated Content
          [x.allocatedContent() == letX] false
          let letX = E1 = E1
          Allocatable[E] has Allocated Content[E1]
          [x.allocatedContent() == letX] true
          [Exists {D, E} { x |x.allocatedContent() == letX}] true
          [F.isHidden()] true
          [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
          [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
        constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

        constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
          let letX = G1 = G1
          Content[G1::NORMAL] is Visible
          Allocatable[A] has Allocated Content[A2]
          [A.allocatedContent() == A2] true
          [!A.allocatedContent() == A2] false
          [(letX.isVisible() -> !A.allocatedContent() == A2)] false
        constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] false

      Content[A1::NORMAL] check online constraints start
        constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
          Allocatable[A] has Allocated Content[A1]
          let letX = A.allocatedContent() = A1
          Allocatable[B] has no Allocated Content
          [x.allocatedContent() == letX] false
          Allocatable[A] has Allocated Content[A1]
          let letX = A.allocatedContent() = A1
          Allocatable[C] has Allocated Content[A2]
          [x.allocatedContent() == letX] false
          [Exists {B, C} { x |x.allocatedContent() == letX}] false
          [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
        constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

        constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
          let letX = G1 = G1
          Content[G1::NORMAL] is Visible
          Allocatable[A] has Allocated Content[A1]
          [A.allocatedContent() == A2] false
          [!A.allocatedContent() == A2] true
          [(letX.isVisible() -> !A.allocatedContent() == A2)] true
        constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

      check online constraints to confirm area hidden state
    Area[A] displays Content[A1::NORMAL] hidden[false]

        Area[F] affect allocatable check start
          Content[F1::NORMAL] check online constraints start
          check online constraints to confirm area hidden state
            constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
              Allocatable[A] has Allocated Content[A1]
              let letX = A.allocatedContent() = A1
              Allocatable[B] has no Allocated Content
              [x.allocatedContent() == letX] false
              Allocatable[A] has Allocated Content[A1]
              let letX = A.allocatedContent() = A1
              Allocatable[C] has Allocated Content[A2]
              [x.allocatedContent() == letX] false
              [Exists {B, C} { x |x.allocatedContent() == letX}] false
              [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
            constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

        Area[F] displays Content[F1::NORMAL] hidden[false]

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1::NORMAL] is Visible
      Allocatable[A] has Allocated Content[A1]
      [A.allocatedContent() == A2] false
      [!A.allocatedContent() == A2] true
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

  check online constraints to confirm area hidden state
Area[G] displays Content[G1::NORMAL] hidden[false]

----Cancel Request----
Content[A1::NORMAL] check start
  Content[A1::NORMAL] is Visible skip
Content[A2::NORMAL] check start
  Content[A2::NORMAL] is not Active skip
Content[B1::NORMAL] check start
  Content[B1::NORMAL] is not Active skip
Content[C1::NORMAL] check start
  Content[C1::NORMAL] is not Active skip
Content[D1::NORMAL] check start
  Content[D1::NORMAL] is not Active skip
Content[E1::NORMAL] check start
  Content[E1::NORMAL] is not Active skip
Content[F1::NORMAL] check start
  Content[F1::NORMAL] is not Active skip
Content[G1::NORMAL] check start
  Content[G1::NORMAL] is not Active skip
----Cancel Request----
Content[A1::NORMAL] check start
  Content[A1::NORMAL] is not Canceled because NEVER_GIVEUP
Content[A2::NORMAL] check start
  Content[A2::NORMAL] is Visible skip
Content[B1::NORMAL] check start
  Content[B1::NORMAL] is not Active skip
Content[C1::NORMAL] check start
  Content[C1::NORMAL] is not Active skip
Content[D1::NORMAL] check start
  Content[D1::NORMAL] is not Active skip
Content[E1::NORMAL] check start
  Content[E1::NORMAL] is not Active skip
Content[F1::NORMAL] check start
  Content[F1::NORMAL] is not Active skip
Content[G1::NORMAL] check start
  Content[G1::NORMAL] is not Active skip
----Cancel Request----
Content[A1::NORMAL] check start
  Content[A1::NORMAL] is not Canceled because NEVER_GIVEUP
Content[A2::NORMAL] check start
  Content[A2::NORMAL] is Visible skip
Content[B1::NORMAL] check start
  Content[B1::NORMAL] is not Active skip
Content[C1::NORMAL] check start
  Content[C1::NORMAL] is not Active skip
Content[D1::NORMAL] check start
  Content[D1::NORMAL] is not Active skip
Content[E1::NORMAL] check start
  Content[E1::NORMAL] is Visible skip
Content[F1::NORMAL] check start
  Content[F1::NORMAL] is not Active skip
Content[G1::NORMAL] check start
  Content[G1::NORMAL] is not Active skip
----Cancel Request----
Content[A1::NORMAL] check start
  Content[A1::NORMAL] is not Canceled because NEVER_GIVEUP
Content[A2::NORMAL] check start
  Content[A2::NORMAL] is Visible skip
Content[B1::NORMAL] check start
  Content[B1::NORMAL] is not Active skip
Content[C1::NORMAL] check start
  Content[C1::NORMAL] is not Active skip
Content[D1::NORMAL] check start
  Content[D1::NORMAL] is not Active skip
Content[E1::NORMAL] check start
  Content[E1::NORMAL] is Visible skip
Content[F1::NORMAL] check start
  Content[F1::NORMAL] is not Canceled because NEVER_GIVEUP
Content[G1::NORMAL] check start
  Content[G1::NORMAL] is not Active skip
----Cancel Request----
Content[A1::NORMAL] check start
  Content[A1::NORMAL] is Visible skip
Content[A2::NORMAL] check start
  Content[A2::NORMAL] is Visible skip
Content[B1::NORMAL] check start
  Content[B1::NORMAL] is not Active skip
Content[C1::NORMAL] check start
  Content[C1::NORMAL] is not Active skip
Content[D1::NORMAL] check start
  Content[D1::NORMAL] is not Active skip
Content[E1::NORMAL] check start
  Content[E1::NORMAL] is Visible skip
Content[F1::NORMAL] check start
  Content[F1::NORMAL] is Visible skip
Content[G1::NORMAL] check start
  Content[G1::NORMAL] is Visible skip
----Check All Constraint----
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

----Check All Constraint----
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has no Allocated Content
      [x.allocatedContent() == letX] false
      [Exists {D, E} { x |x.allocatedContent() == letX}] false
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

----Check All Constraint----
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] true
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

----Check All Constraint----
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A2]
      let letX = A.allocatedContent() = A2
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] true
      [Exists {B, C} { x |x.allocatedContent() == letX}] true
      let letX = E1 = E1
      Allocatable[D] has no Allocated Content
      [x.allocatedContent() == letX] false
      let letX = E1 = E1
      Allocatable[E] has Allocated Content[E1]
      [x.allocatedContent() == letX] true
      [Exists {D, E} { x |x.allocatedContent() == letX}] true
      [F.isHidden()] true
      [(Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden())] true
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1] is not Visible
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

----Check All Constraint----
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] check start
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[B] has no Allocated Content
      [x.allocatedContent() == letX] false
      Allocatable[A] has Allocated Content[A1]
      let letX = A.allocatedContent() = A1
      Allocatable[C] has Allocated Content[A2]
      [x.allocatedContent() == letX] false
      [Exists {B, C} { x |x.allocatedContent() == letX}] false
      [(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true
    constraint expression[(Exists {B, C} { x |x.allocatedContent() == letX} -> (Exists {D, E} { x |x.allocatedContent() == letX} -> F.isHidden()))] true

    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] check start
      let letX = G1 = G1
      Content[G1::NORMAL] is Visible
      Allocatable[A] has Allocated Content[A1]
      [A.allocatedContent() == A2] false
      [!A.allocatedContent() == A2] true
      [(letX.isVisible() -> !A.allocatedContent() == A2)] true
    constraint expression[(letX.isVisible() -> !A.allocatedContent() == A2)] true

----Result Information----
Allocatable TotalCount:7
  Area[A] Content[A1::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[null] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[null] hidden[false]
  Area[F] Content[null] hidden[false]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[true] cancel[false]
    allocated Area[A]
  ViewContent[A2] visible[false] cancel[false]
  ViewContent[B1] visible[false] cancel[false]
  ViewContent[C1] visible[false] cancel[false]
  ViewContent[D1] visible[false] cancel[false]
  ViewContent[E1] visible[false] cancel[false]
  ViewContent[F1] visible[false] cancel[false]
  ViewContent[G1] visible[false] cancel[false]
----Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[null] hidden[false]
  Area[F] Content[null] hidden[false]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] cancel[false]
  ViewContent[A2] visible[true] cancel[false]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] cancel[false]
  ViewContent[C1] visible[false] cancel[false]
  ViewContent[D1] visible[false] cancel[false]
  ViewContent[E1] visible[false] cancel[false]
  ViewContent[F1] visible[false] cancel[false]
  ViewContent[G1] visible[false] cancel[false]
----Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[E1::NORMAL] hidden[false]
  Area[F] Content[null] hidden[true]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] cancel[false]
  ViewContent[A2] visible[true] cancel[false]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] cancel[false]
  ViewContent[C1] visible[false] cancel[false]
  ViewContent[D1] visible[false] cancel[false]
  ViewContent[E1] visible[true] cancel[false]
    allocated Area[E]
  ViewContent[F1] visible[false] cancel[false]
  ViewContent[G1] visible[false] cancel[false]
----Result Information----
Allocatable TotalCount:7
  Area[A] Content[A2::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[E1::NORMAL] hidden[false]
  Area[F] Content[F1::NORMAL] hidden[true]
  Area[G] Content[null] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[false] cancel[false]
  ViewContent[A2] visible[true] cancel[false]
    allocated Area[A]
    allocated Area[C]
  ViewContent[B1] visible[false] cancel[false]
  ViewContent[C1] visible[false] cancel[false]
  ViewContent[D1] visible[false] cancel[false]
  ViewContent[E1] visible[true] cancel[false]
    allocated Area[E]
  ViewContent[F1] visible[false] cancel[false]
    allocated Area[F]
  ViewContent[G1] visible[false] cancel[false]
----Result Information----
Allocatable TotalCount:7
  Area[A] Content[A1::NORMAL] hidden[false]
  Area[B] Content[null] hidden[false]
  Area[C] Content[A2::NORMAL] hidden[false]
  Area[D] Content[null] hidden[false]
  Area[E] Content[E1::NORMAL] hidden[false]
  Area[F] Content[F1::NORMAL] hidden[false]
  Area[G] Content[G1::NORMAL] hidden[false]
Content TotalCount:8
  ViewContent[A1] visible[true] cancel[false]
    allocated Area[A]
  ViewContent[A2] visible[true] cancel[false]
    allocated Area[C]
  ViewContent[B1] visible[false] cancel[false]
  ViewContent[C1] visible[false] cancel[false]
  ViewContent[D1] visible[false] cancel[false]
  ViewContent[E1] visible[true] cancel[false]
    allocated Area[E]
  ViewContent[F1] visible[true] cancel[false]
    allocated Area[F]
  ViewContent[G1] visible[true] cancel[false]
    allocated Area[G]

